#! /usr/bin/env Rscript
library(annotatr)
library(dplyr)
library(ggplot2)
library(argparser)
#NOTE: TxDB, org.*.eg.db datbases need to be available but not necessarily loaded.
# Loading of the oppropriate DB can be done by annotatr. 


#' @title Filter built-in annotations
#' @description Filter built-in annotations by include and exclude patterns.
#' @param include A character vector of patterns to include.
#' @param exclude A character vector of patterns to exclude.
#' @return A filtered character vector of built-in annotations. 
#' @examples
#' annotations <- filter_built_in_annotations(
#' include = "hg19",
#' exclude = c("H1hesc", "Hmec", "Huvec", "Nhek", "Gm12878",
#'             "Hepg2","Hsmm", "K562", "Nha", "Nhlf"))
filter_built_in_annotations <- function(include = c("hg19"),
                                        exclude = c("H1hesc", "Hmec")) {
  anno <- builtin_annotations()
  built_in_annotations <- anno[grepl(paste(include, collapse = "|"), anno)
                                 & !grepl(paste(exclude, collapse = "|"), anno)]
  return(built_in_annotations)
}


# The vignettes for annotatr suggest that the regions should be randomized
# they suggest using regioneR::randomizeRegions() that creates a new set of regions with the same
# as the original regions but with randomized positions. For DMR analysis where we have tiles of all
# covered CpGs in the genome (e.g. generated with the script I wrote for DMR identification using
# methylKit) I think it is better to take a sample of the tiles to use as random regions. This way
# we can compare the DMRs to regions that have the same CpG coverage.I will write two functions.
# One that takes a sample of the tiles and another that randomizes the regions.
#' @title Randomize regions
#' @description Randomize the regions. See regioneR::randomizeRegions() for more details. 
randomise_and_annotate <- function(regions, annotations) {
  random_regions <- randomize_regions(
    regions = regions,
    allow.overlaps = TRUE,
    per.chromosome = TRUE)

  # Annotate the random regions using the same annotations used for the regions of interest
  random_regions_annotated <- annotate_regions(
    regions = random_regions,
    annotations = annotations,
    ignore.strand = TRUE,
    quiet = TRUE)

  return(random_regions_annotated)
}

#' @title randomly sample regions and annotate them
#' @description Generate "random annotations", sampled from given regions, to be compared with annotations of a region
#' of intrest. (originally written to sample and annotate tiles from methylation data with the same coverage
#' requirements as the DMRs generated by find_dmrs_methylkit_v3.R)
#'@param sample_from A GRanges object to sample from.
#'@param n The number of regions to sample.
#'@param annotations A GRanges object of annotations generated with the annotatr package.
#'@example random_tiles_annotated <- annotate_random_sample(all_tiles, length(dmrs_with_status), annotations)
annotate_random_sample <- function(sample_from, n, annotations) {
  sampled <- sample(sample_from, n)
  sampled_annotated <- annotate_regions(sampled, annotations)
  return(sampled_annotated)
}

unite_dmrs <- function(hypo_dmrs, hyper_dmrs) {
  # Add a status column to the regions
  hypo_dmrs$status <- 'hypo'
  hyper_dmrs$status <- 'hyper'

  # merge 2 GRanges objects
  dmrs_with_status <- c(hypo_dmrs, hyper_dmrs)

  return(dmrs_with_status)
}

annotation_plots <- function(dmrs, dmrs_annotated, all_tiles, annotations, annotation_order) {
  #Initialize an empty list to store the plots
  plot_list <- list()
  for (st in c("all", "hyper", "hypo")) {
    if (st == "all") {
      n_random <- length(dmrs)
      annotated_regions <- dmrs_annotated
      suffix <- 'all'
    } else {
      n_random <- length(dmrs %>% subset(status == st))
      annotated_regions <- dmrs_annotated %>% subset(status == st)
      suffix <- st
    }

    # Create the plot with and without random regions
    for (random in c(FALSE, TRUE)) {
      if (random) {
        suffix <- paste0(suffix, '_with_random')
        random_tiles_annotated <- annotate_random_sample(all_tiles, n_random, annotations)
        plot <- plot_annotation(
          annotated_regions = annotated_regions,
          annotation_order = annotation_order,
          annotated_random = random_tiles_annotated,
          plot_title = paste('Number of Regions per Annotation in', st, 'DMRs With Random Tiles as Control'),
          x_label = 'knownGene Annotation',
          y_label = 'Count')
        #add subtitle to the plot
        plot <- plot + labs(subtitle = 'NOTE: random tiles may have more/less annotations than the same # of DMRs\nbecause of multiple annotations per region.')
      } else {
        plot <- plot_annotation(
          annotated_regions = annotated_regions,
          annotation_order = annotation_order,
          plot_title = paste('Number of Regions per Annotation in', st, 'DMRs'),
          x_label = 'knownGene Annotation',
          y_label = 'Count')
      }
      # Add the plot to the list
      plot_list[[paste0("annotations_barplot_", suffix)]] <-
        plot + theme(plot.title = element_text(hjust = 0.5),
                     plot.subtitle = element_text(hjust = 0.5))
    }
  }
  return(plot_list)
}

numerical_plots <- function(dmrs_annotated, annots_order, bin_width = 5) {
  # x-axis is methylation difference, y-axis is density.
  # The desity is ploted for all annotations on top of each annotation
  meth_diff_annot <- plot_numerical(
    annotated_regions = dmrs_annotated,
    x = 'meth.diff',
    facet = 'annot.type',
    facet_order = annots_order,
    bin_width = bin_width,
    plot_title = 'methylation difference density by annotation',
    x_label = 'Regions')

  # # NOTE: I don't love this - is there a way to get rid of the density for all annotations
  # # on top of each annotation?'
  meth_diff_annot_status <- plot_numerical(
    annotated_regions = dmrs_annotated,
    x = 'meth.diff',
    facet = c('annot.type', 'status'),
    facet_order = list(annots_order, c('hyper', 'hypo')),
    bin_width = bin_width,
    plot_title = 'methylation difference density by annotation and status',
    x_label = 'Methylation Difference')

  return(list(methylation_difference_density_by_annotation = meth_diff_annot,
              methylation_difference_density_by_annotation_and_status = meth_diff_annot_status))
}

##Plotting Categorical Data##
categorical_plots <- function(dmrs_annotated, annots_order, random_tiles_annotated, x_order = c('hyper', 'hypo')) {
  # Make a barplot of the data class where each bar
  # is composed of the counts of annotations.
  dm_vs_cpg_cat1 = plot_categorical(
    annotated_regions = dmrs_annotated, x = 'status', fill = 'annot.type',
    x_order = x_order, fill_order = annots_order, position = 'stack',
    plot_title = 'DMR Annotation Counts by Status',
    legend_title = 'Annotations',
    x_label = 'DMR status',
    y_label = 'Count')

  # Use the same order vectors as the previous code block,
  # but use proportional fill instead of counts.
  dm_vs_cpg_cat2 = plot_categorical(
    annotated_regions = dmrs_annotated, x = 'status', fill = 'annot.type',
    x_order = x_order, fill_order = annots_order, position = 'fill',
    plot_title = 'DMR Annotation Proportions by Status',
    legend_title = 'Annotations',
    x_label = 'DMR status',
    y_label = 'Proportion')


  dm_vs_cpg_cat_random = plot_categorical(
    annotated_regions = dmrs_annotated, annotated_random = random_tiles_annotated,
    x = 'status', fill = 'annot.type',
    x_order = x_order, fill_order = annots_order, position = 'fill',
    plot_title = 'DMR Annotation Proportions by Status with Random Tiles as Control',
    legend_title = 'Annotations',
    x_label = 'DMR status',
    y_label = 'Proportion')

  #swich the x and fill to see the status proportion in each annotation
  dm_vs_cpg_cat3 = plot_categorical(
    annotated_regions = dmrs_annotated, x = 'annot.type', fill = 'status',
    x_order = annots_order, fill_order = x_order, position = 'fill',
    plot_title = 'DMR Status Proportions by Annotation',
    legend_title = 'DMR status',
    x_label = 'Annotation',
    y_label = 'Proportion')

  # status counts in each annotation
  dm_vs_cpg_cat4 = plot_categorical(
    annotated_regions = dmrs_annotated, x = 'annot.type', fill = 'status',
    x_order = annots_order, fill_order = x_order, position = 'stack',
    plot_title = 'DMR Status Counts by Annotation',
    legend_title = 'DMR status',
    x_label = 'Annotation',
    y_label = 'Count')

  return(list(dmr_annotation_counts_by_status = dm_vs_cpg_cat1,
              dmr_annotattions_proportions_by_status = dm_vs_cpg_cat2,
              dmr_annotation_proportions_by_status_with_random = dm_vs_cpg_cat_random,
              dmr_status_proportions_by_annotation = dm_vs_cpg_cat3,
              dmr_status_counts_by_annotation = dm_vs_cpg_cat4))
}

print_plts <- function(annotation_plots, numerical_plots, categorical_plots) {
  # Print the plots
  for (plot in annotation_plots) {
    cat("Printing annotation plots\n")
    print(plot)
  }
  for (plot in numerical_plots) {
    cat("Printing numerical plots\n")
    print(plot)
  }
  for (plot in categorical_plots) {
    cat("Printing categorical plots\n")
    print(plot)
  }
}

# function should accept a single plot or a list of plots or multiple lists of plots, it should handle as many argumwnts as are given
# and print them all.
#can I do somethiong like this? function(plot,plot_list1, plot_list2, ...,  output_dir = "./annotatr_plots")
plot_png_saver <- function(output_dir = "./annotatr_plots", ...) {
  # Create the output directory if it doesn't exist including parent directories
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }
  # Convert the ... arguments into a list or list of lists
  plot_list <- list(...)
  for (lst in plot_list) {
    for (plot_name in names(lst)) {
      # Generate a file name for the plot
      file_name <- paste0(plot_name, ".png")
      cat("Saving plot", file_name, "\n")
      # # Save the plot as a PNG file
      png(filename = file.path(output_dir, file_name), width = 1200, height = 1000, res = 150)
      print(lst[[plot_name]])
      dev.off()
    }
  }
}

annotate_dmrs_annotatr_main <- function(hypo_dmrs, hyper_dmrs, all_tiles, genome = "hg19",
                                        internet = FALSE, print_plots = FALSE, save_plots = TRUE,
                                        output_dir = "./annotatr_plots/")
{
  dmrs <- unite_dmrs(hypo_dmrs, hyper_dmrs)

  #choose annotations to use
  #enhancers and lncRNAs require FTP download
  #TODO: add option for user supllied custom annotations
  if (internet) {
    annotations <- filter_built_in_annotations(
      include = genome,
      exclude = c("H1hesc", "Hmec", "Huvec", "Nhek", "Gm12878",
                  "Hepg2", "Hsmm", "K562", "Nha", "Nhlf")
    )
  } else {
    annotations <- paste0(genome, "_basicgenes")
  }
  # Annotate the regions
  # Note that one region can overlap multiple annotations
  #TODO: write options to deal with this.
  # TODO: how many regions have mulitple annotations?
  # TODO: option to keep only one according to priority
  # TODO: option to see all annotations (upset plot?)
  annotations <- build_annotations(genome, annotations)
  dmrs_annotated <- annotate_regions(dmrs, annotations)

  annots_order <- dmrs_annotated$annot$type %>% sort %>% unique
  annotation_plts <- annotation_plots(dmrs, dmrs_annotated, all_tiles, annotations, annots_order)
  cat("Annotation plots done\n")
  numerical_plts <- numerical_plots(dmrs_annotated, annots_order)
  cat("Numerical plots done\n")
  random_tiles_annotated <- annotate_random_sample(all_tiles, length(dmrs), annotations) #replaced with sampling in the figure loop
  categorical_plts <- categorical_plots(dmrs_annotated, annots_order, random_tiles_annotated)
  cat("Categorical plots done\n")

  if (print_plots)
    print_plts(annotation_plts, numerical_plts, categorical_plts)
  if (save_plots)
    plot_png_saver(output_dir, annotation_plts, numerical_plts, categorical_plts)

  #TODO:
  #save csv file for each annotation with a columns of the annotation region,gene symbols and, the number of regions with the annotation
  #start with one annotation: "promoters"
  # dmrs_annotated_promoters <- dmrs_annotated %>% subset(grepl("promoters", .$annot$type))
  #count the number of unique ranges in the GRanges object
  # n_uniq_ranges <- length(reduce(dmrs_annotated_promoters))

}

# parse cli args and pass them to the function
parse_cli_args <- function() {
  p <- arg_parser("Annotate DMRs with annotatr")
  p <- add_argument(p, "--hypo_dmrs", help = "path to GRanges object saved as rds containing hypomethylated DMRs ")
  p <- add_argument(p, "--hyper_dmrs", help = "path to GRanges object saved as rds containing hypermethylated DMRs ")
  p <- add_argument(p, "--all_tiles", help = "path to GRanges object saved as rds containing all tiles (the DMRs are a subset of these)")
  p <- add_argument(p, "--genome", help = "genome to use for annotations (available on container: hg19, hg38, mm9, mm10)", default = "hg19")
  p <- add_argument(p, "--internet", help = "use internet to download more than the basic_genes annotations", flag = TRUE)
  p <- add_argument(p, "--print_plots", help = "print the plots to the console. For use in IDE", flag = TRUE)
  p <- add_argument(p, "--dont_save_plots", help = "don't save the plots as png files", flag = TRUE)
  p <- add_argument(p, "--output_dir", help = "directory to save the plots", default = "./annotatr_plots")
  args <- parse_args(p)
  return(args)
}

# parse the command line arguments
argv <- parse_cli_args()

#print the given arguments
cat("Annotating DMRs with annotatr\n")
cat("Hypomethylated DMRs: ", argv$hypo_dmrs, "\n")
cat("Hypermethylated DMRs: ", argv$hyper_dmrs, "\n")
cat("All tiles: ", argv$all_tiles, "\n")
cat("Genome: ", argv$genome, "\n")
cat("Use internet: ", argv$internet, "\n")
cat("Print plots: ", argv$print_plots, "\n")
cat("Save plots: ", !argv$dont_save_plots, "\n")
cat("Output directory: ", argv$output_dir, "\n")

#debug
outdir <<- argv$output_dir

# pass the arguments to the main function
annotate_dmrs_annotatr_main(
  readRDS(argv$hypo_dmrs), readRDS(argv$hyper_dmrs), readRDS(argv$all_tiles),
  argv$genome, argv$internet, argv$print_plots, !argv$dont_save_plots,
  argv$output_dir
)

#for manual use
# internet <- FALSE
# genome <- "hg19"
# print_plots <- TRUE
# save_plots <- TRUE
# hypo_dmrs <- readRDS("./analysis/DMRs/LNCaP_vs_PrEC_pidelsy2016/dmrs_hypo_200bpTiles_25perc_basecov1_tilecov10.rds.GRanges")
# hyper_dmrs <- readRDS("./analysis/DMRs/LNCaP_vs_PrEC_pidelsy2016/dmrs_hyper_200bpTiles_25perc_basecov1_tilecov10.rds.GRanges")
# all_tiles <- readRDS("./analysis/DMRs/LNCaP_vs_PrEC_pidelsy2016/raw_unite_200bpTiles_25perc_basecov1_tilecov10.rds.GRanges")
# output_dir <- "./analysis/DMRs/LNCaP_vs_PrEC_pidelsy2016/annotatr_plots"

# annotate_dmrs_annotatr_main(hypo_dmrs, hyper_dmrs, all_tiles, genome, internet,
#                             print_plots, save_plots, output_dir)
